#+TITLE:
#+AUTHOR:    David Spångberg
#+EMAIL:     david@tunna.org
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+LATEX_HEADER: \usepackage[margin=3.5cm]{geometry}
#+LATEX_HEADER: \usepackage{lipsum, listings, xcolor, fancyhdr}
#+LATEX_HEADER: \usepackage[style=alphabetic,citestyle=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{references.bib}

# #### Palatino font
#+LATEX_HEADER: \usepackage[sc]{mathpazo}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \linespread{1.05} % Palatino needs more leading (space between lines)

#+BEGIN_LATEX
\hyphenation{testing}
\hyphenation{abstract}
\hyphenation{optimizations}
\hyphenation{successfully}

\thispagestyle{empty}
\setlength{\parskip}{0.2cm}
\setlength{\parindent}{0pt}

\lstset
{
keywordstyle=\textbf,
numbers=left,
numberstyle=\scriptsize,
frame=l,
numbersep=7pt,
xleftmargin=10pt
}

\lstloadlanguages{Haskell}
\lstnewenvironment{haskell}
    {\lstset{
        frame=none,
        xleftmargin=2pt,
        stepnumber=1,
        numbers=left,
        numbersep=5pt,
        numberstyle=\ttfamily\tiny\color[gray]{0.3},
        belowcaptionskip=\bigskipamount,
        captionpos=b,
        escapeinside={*'}{'*},
        language=haskell,
        tabsize=2,
        emphstyle={\bf},
        commentstyle=\it,
        stringstyle=\mdseries\rmfamily,
        showspaces=false,
        keywordstyle=\bfseries\rmfamily,
        columns=flexible,
        basicstyle=\small\sffamily,
        showstringspaces=false,
        morecomment=[l]\%,
      }%
      \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}

\newcommand{\inlhask}[1]{\lstinline[language=haskell]§#1§}

\begin{center}
\includegraphics{logo_gu.eps}

\vspace{2cm}

\hrule \bigskip
{\Huge API-driven generation of well-typed terms} \bigskip
\hrule

\vspace{1.5cm}

{\Large Master Thesis Project}

\vspace{5cm}

\Large David Spångberg \texttt{<davspa@student.gu.se>} \bigskip

\today
\end{center}

\newpage

\newcommand{\note}[1]{{\color{blue} Note: \emph{#1}}}
\newcommand{\todo}[1]{{\color{red} TODO: \emph{#1}}}
#+END_LATEX

\pagestyle{empty}

\vspace*{3.5cm}

\begin{center}
\textbf{\large{Abstract}}
\end{center}

\todo{Skriv abstract!}

\newpage

#+TOC: headlines 3

\newpage

\lhead{\emph \rightmark}
\rhead{\emph \leftmark}
\pagestyle{fancy}

\setcounter{page}{1}

* Problem background
  \note{Flytta delar till abstract respektive intro}

  When developing a compiler for a Domain Specific Language (DSL) one
  often want to test certain aspects of the compiler. For instance,
  testing that the result of evaluating an expression produces the
  same result both before and after certain optimizations. One way to
  achieve this is to design unit tests that cover all developed
  optimizations. This approach has several limitations. For instance,
  when new optimizations are added, new unit tests have to be
  developed. Similarly, when optimizations are modified, the
  corresponding unit tests have to be updated.

  Instead, when testing compilers, it might be possible to construct a
  generator for random Abstract Syntax Trees (AST) of the given
  language and use this generator to test the optimizations. However,
  these ASTs might have several invariants and constructing a
  generator producing only valid ASTs might be non-trivial. One
  solution to this problem is to only use smart constructors given by
  an API to produce values of the requested type. However, combining
  these smart constructors in a sensible way might be equally
  non-trivial.

  Aspects of the compiler other than optimizations can also be tested
  in similar ways. One example is testing that interpreting a program
  versus compiling and executing it produces the same result. This
  test and several others has similar preconditions as the
  optimization tests, it requires that a program is somehow generated
  or constructed before the test in question can finish.

\newpage

* Introduction
** Problem description
** Literature

\newpage

* Implementation
  In this chapter the current implementation is explained thoroughly.
  First the data types used to represent, for instance, types and
  values is presented together with the functions used to work with
  the respective data types. Some of the limitations imposed by the
  specific representation scheme presented in this chapter is also
  discussed.

** Types and expressions
*** Variables, Forall and Undecided
*** Types and simple types
*** Constructors
*** Expressions
*** Other types
**** Languages
**** Contexts
**** Substitutions
**** Class environments
**** Equality constraints
** Template Haskell
   The library contains a small module =TH= with one exported Template
   Haskell function =defineLanguage= that an user can use to construct
   a =Language=.

   \todo{Discuss todo in getClassEnv.}

** ExpGen
   The =ExpGen= module contains the core algorithm and methods to
   generate type-safe expressions. The generation starts in the
   appropriately named function =generate= which works by finding
   matching =Constructor='s for the current goal type and recursively
   tries to generate expressions of the argument types used in the
   constructor. However, this is not as trivial as the above
   description makes it sound like and the following section explains
   the design choices and the different invariants used when
   implementing the complete algorithm.

*** The ExpGen state
*** Unique types
*** Match function
*** Selecting a random matching constructor
*** Generating expressions

\newpage

* Limitations
  Due to time limitations the scope and complexity of the project was
  reduced by limiting the implementation of the final project. This
  chapter discusses all these limitations and how they affect the
  final product. Further, each subsection contains a short discussion
  about how one might extend the library to eliminate the limitation.

** Type matching
** Rank >1 types
** Class environments

\newpage

* Example usage
** Simple usage
** a Do-it-yourself High-Assurance compiler
** Feldspar

\newpage

* Future Work

\newpage

* Related work

\newpage

* Conclusions

\newpage

\section*{References}

# Mark all references as cited
  \nocite{*}

  \printbibliography[heading=none]
