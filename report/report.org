#+TITLE:
#+AUTHOR:    David Spångberg
#+EMAIL:     david@tunna.org
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+LATEX_HEADER: \usepackage[margin=3.5cm]{geometry}
#+LATEX_HEADER: \usepackage{lipsum, minted, xcolor, fancyhdr, xspace}
#+LATEX_HEADER: \usepackage[style=alphabetic,citestyle=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{references.bib}

# #### Palatino font
#+LATEX_HEADER: \usepackage[sc]{mathpazo}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \linespread{1.05} % Palatino needs more leading (space between lines)

#+BEGIN_LATEX
\hyphenation{testing}
\hyphenation{abstract}
\hyphenation{optimizations}
\hyphenation{successfully}

\setlength{\parskip}{0.2cm}
\setlength{\parindent}{0pt}

\newcommand{\quickgen}[0]{\textsc{QuickGen}\xspace}
\newcommand{\note}[1]{{\color{blue} Note: \emph{#1}}}
\newcommand{\todo}[1]{{\color{red} \textbf{TODO:} \emph{#1}}}

\newminted{haskell}{linenos}
\newcommand{\inlhask}[1]{\mintinline{haskell}?#1?}

% It is probably possible to do this without having a -3pt hspace.
% There probably even exists such a library or command that does what
% I want.
\newenvironment{mycitation}
  { \begin{center}\begin{minipage}{\textwidth-2cm}%
    \em \hspace{0.5cm} "\hspace{-3pt}%
  }
  {\hspace{-3pt}"%
    \end{minipage}\end{center}
  }

\newenvironment{todo*}
  {\color{red} \textbf{TODO:} \em}
  {}

%%% Front page
\thispagestyle{empty}
\begin{center}
\includegraphics{logo_gu.eps}

\vspace{2cm}

\hrule \bigskip
{\Huge API-driven generation of well-typed terms} \bigskip
\hrule

\vspace{1.5cm}

{\Large Master Thesis Project}

\vspace{5cm}

\Large David Spångberg \texttt{<davspa@student.gu.se>} \bigskip

\today
\end{center}

\newpage
#+END_LATEX

\pagestyle{empty}

\vspace*{3.5cm}

\begin{center}
\textbf{\large{Abstract}}
\end{center}

\todo{Skriv abstract!}

\newpage

#+TOC: headlines 3

\newpage

\lhead{\emph \rightmark}
\rhead{\emph \leftmark}
\pagestyle{fancy}

\setcounter{page}{1}

* Problem background
  \note{Flytta delar till abstract respektive intro}

  When developing a compiler for a Domain Specific Language (DSL) one
  often want to test certain aspects of the compiler. For instance,
  testing that the result of evaluating an expression produces the
  same result both before and after certain optimizations. One way to
  achieve this is to design unit tests that cover all developed
  optimizations. This approach has several limitations. For instance,
  when new optimizations are added, new unit tests have to be
  developed. Similarly, when optimizations are modified, the
  corresponding unit tests have to be updated.

  Instead, when testing compilers, it might be possible to construct a
  generator for random Abstract Syntax Trees (AST) of the given
  language and use this generator to test the optimizations. However,
  these ASTs might have several invariants and constructing a
  generator producing only valid ASTs might be non-trivial. One
  solution to this problem is to only use smart constructors given by
  an API to produce values of the requested type. However, combining
  these smart constructors in a sensible way might be equally
  non-trivial.

  Aspects of the compiler other than optimizations can also be tested
  in similar ways. One example is testing that interpreting a program
  versus compiling and executing it produces the same result. This
  test and several others has similar preconditions as the
  optimization tests, it requires that a program is somehow generated
  or constructed before the test in question can finish.

\newpage

* Introduction
** Problem description
** Literature

\newpage

* Implementation
  In this chapter the current implementation is explained thoroughly.
  First the data types used to represent, for instance, types and
  values is presented together with the functions used to work with
  the respective data types. Some of the limitations imposed by the
  specific representation scheme for the types presented is also
  discussed. After this a brief presentation of the template haskell
  part of the library is discussed and some examples are presented.

  Finally, the implementation of the code generation and matching is
  presented thoroughly. Initially a high level description of the
  implementation is presented together with a explanation of how the
  different functions fit together. Later the most important functions
  are presented in detail. This is done by reasoning about several
  edge-cases, invariants and the actual implementation of the
  functions in question.

** Types and expressions
*** Variables, Forall and Undecided
    \label{variables}

    In Haskell a type can contain forall quantified type variables.
    For instance in the type for \inlhask{id :: a -> a} an implicit
    forall for the type variable =a= is introduced resulting in the
    final type \inlhask{id :: forall a. a -> a}. This type says that
    \inlhask{id} works for *any* type =a=, be it integers, list of
    strings or functions containing their own forall quantified type
    variables. \quickgen introduces another kind of quantifier,
    \inlhask{Undecided}. Basically, an undecided variable is
    introduced during type matching when a forall quantified variable
    has nothing to do with the matched type. Lets consider an example:

    A user wants to generate some expression of type \inlhask{[Int]}
    and \inlhask{map :: (a -> b) -> [a] -> [b]} is one of the
    available functions in the user API. When these types reach the
    matching function the matching proceeds by only considering the
    return type of \inlhask{map}, \inlhask{[b]}. The matching succeeds
    and a substitution from \inlhask{Int} to =b= and the current
    matched type now looks like: \inlhask{map :: (a -> Int) -> [a] ->
    [Int]}. As you can see, the type =a= does not have anything to do
    with the matched type \inlhask{[Int]} and can therefore be any
    type. It can be a forall quantified type variable or it can be a
    more specilized type, for instance \inlhask{[Double]}. In this
    case the matching algorithm will therefore return something
    similar to: \inlhask{map :: undecided a. (a -> Int) -> [a] ->
    [Int]}.

    With these explanations we can now look at how \quickgen encodes
    type variables internally:

    \begin{haskellcode}
    data Quantifier = Forall | Undecided
    type Nat = Int
    type Variable = (Nat, Quantifier)
    \end{haskellcode}

    Simply put, instead of storing the name of a type variable as a
    string, a natural number is used instead. This is done for
    performance reasons and is explained more in section \ref{match}.
    Finally, the quantifier for the variable is also included in the
    \inlhask{Variable} type alias.

*** Constructors
    \label{constructors}

    A constructor is the term used for the haskell functions found in
    the specified user API. The intuition is that one of these terms
    can be used to construct parts of an haskell expression. The
    internal representation of a constructor is very simple:

    \begin{haskellcode}
    type Name = TH.Name
    type Constructor = (Name, Type)
    \end{haskellcode}

    A \inlhask{Name} is simply a type alias for names in Template
    Haskell \cite{TH}. A \inlhask{Type} corresponds to the, possibly
    specialized, type of the constructor. Types are discussed in the
    next section and how to a specialize a type for a constructor is
    explained in section \ref{TH}.

*** Types and simple types
    Below are the two data types in \quickgen that are used to
    represent types in Haskell:

    \begin{haskellcode}
    data Type = Type [Variable] Cxt SType

    data SType =
        FunT [SType]
      | VarT Variable
      | ConT Name [SType]
      | ListT SType
    \end{haskellcode}

    The first data type is used to introduce variables, and
    constraints on these variables, in types. The second data type
    =SType= has constructors for representing functions, variables,
    constructors \ref{constructors} and lists. For instance the the
    implicitly forall quantified type \inlhask{a -> b -> b} could be
    represented as

    \begin{haskellcode}
    Type [(0, Forall), (1, Forall)] [] (FunT [ VarT (1, Forall)
                                             , VarT (1, Forall)
                                             , VarT (0, Forall)
                                             ])
    \end{haskellcode}

    The name of a type variable are turned into a natural number and a
    quantifier (here Forall) as explained in \ref{variables} . The
    type variable =a= is here turned into \inlhask{(0, Forall)} and
    =b= is turned into \inlhask{(1, Forall)}. A not so obvious
    transformation is done for the inner =SType=. The order of the
    type variables in the function type is reversed if you compare to
    the original type. The reason this is done is to make the
    implementation of the type matching more efficient. This is
    discussed in section \ref{match}. For now, it is enough to
    remember that function types are reversed.

    The rest of the constructors, \inlhask{VarT, ConT} and
    \inlhask{ListT} represents type variables, type constructors and
    lists respectively. The observant reader may notice that there is
    currently no way to represent type variables with arguments, i.e.
    there is no way to represent the type of \inlhask{return :: Monad m => a -> m a}
    This limitation and ways to solve it are discussed further in
    section \ref{lim-typearg}.

    The reason there is an extra constructor \inlhask{ListT} for lists
    instead of representing them as \inlhask{ConT "List" a} [fn:1] is
    just a convenience which make the implementation simpler, it also
    follows the representation for types used in Template Haskell
    \cite{TH}.

*** Expressions
    The following data type is used for the generated expressions in
    \quickgen:

    \begin{haskellcode}
    data Exp =
        ConE Name
      | AppE Exp Exp
      | LamE [Name] Exp
    \end{haskellcode}

    An expression is either the name of a \inlhask{Constructor}
    \ref{constructors}, an expression applied to another expression or
    a lambda expression. The list of \inlhask{Name}'s in a lambda
    expression will always be non empty. This data types is very
    simple when compared to the expression data type used by Template
    Haskell \cite{TH}. However, this means that some haskell
    expressions, like case- and let-expressions, cannot be generated
    by the library. This limitation and why this has little effect on
    the usability of the library is discussed more in section
    \ref{lim-expressions}.

*** Other types
**** *Substitutions:*
     \label{types-subst}

     \todo{Elaborate on Undecided type variables.}

     A mapping from type identifiers, natural numbers, to simple
     types, \inlhask{SType}'s. There is a value of this type in the
     state when generating expressions. This value only contain
     mappings for \inlhask{Undecided} variables since the
     \inlhask{Forall} quantified variables has already been bound. The
     \inlhask{Types} module contains several functions [fn:2] for
     transforming and getting information from
     \inlhask{Substitution}'s.

**** *Contexts* and *Uses*:
     A \inlhask{Context} is a mapping from type identifiers to
     constructors paired together with the available \inlhask{Uses}
     left for each particular constructor.

     \begin{haskellcode}
     type Uses = Maybe Nat
     type Context = Map Id (Uses, Constructor)
     \end{haskellcode}

     The number of uses can either be \inlhask{Just} a natural number
     or \inlhask{Nothing}, the latter indicating that this particular
     constructor can be used an unlimited number of times. Further
     discussion relating to \inlhask{Uses} can be found in section
     \ref{random}.

**** *Class environments:*
     A mapping from names of Haskell type classes to a list of super
     classes paired with the Template Haskell instance declaration.

     \begin{haskellcode}
     type ClassEnv = Map Name ([Name], [TH.InstanceDec])
     \end{haskellcode}

     Currently the class environment is not used internally apart from
     being constructed in the Template Haskell module. Future work
     regarding the usage of this type is discussed in section
     \ref{fut-CE}.

**** *Languages:*
     \label{types-languages}

     Basically a \inlhask{ClassEnv} paired together with a list of
     \inlhask{Constructor}'s. A \inlhask{Language}'s is one of the
     arguments for the library function \inlhask{generate}, the other
     two being a \inlhask{Type} and a \inlhask{Seed} [fn:3]. The
     \inlhask{generate} function together with a value of these three
     types are the only thing a user needs to generate well-typed
     terms using this library. Currently the only way for an end user
     to construct a value of this type is via the Template Haskell
     function \inlhask{defineLanguage}.

** Template Haskell
   \label{TH}

   \begin{todo*}
   This section is too damn long! Maybe only keep the pseudocode and
   move parts to future work section
   \end{todo*}

   The library contains a small module =TH= with one exported Template
   Haskell function =defineLanguage= that an user can use to construct
   a =Language=. Below follows an example usage of this function:

   \begin{haskellcode}
   genInt = 0 :: Int
   nil  = []
   cons = (:)

   lang :: Language
   lang = $(defineLanguage [| ( genInt, nil, cons
                              , id, map
                              ) |])
   \end{haskellcode}

   As you might suspect, it is currently not possible to directly
   include \inlhask{(:)} and \inlhask{[]}, the only thing that is
   accepted is names of functions. How one might possibly add this
   functionality is discussed in section \ref{fut-defineLanguage}.

   There is also one additional form when specifying API functions:

   \begin{haskellcode}
   $(defineLanguage [| (map :: (a -> Int) -> [a] -> [Int], id) |])
   \end{haskellcode}

   This specializes the type of \inlhask{map} so that it can only be
   used to construct expressions of type \inlhask{[Int]}.

*** Calculating a class environment
    As mentioned in section \ref{types-languages}, a
    \inlhask{Language} is isomorphic to a \inlhask{ClassEnv} paired
    with a list of \inlhask{Constructor}'s. The easiest way to explain
    how a class environment is calculated is probably by presenting
    the documentation for the internal function \inlhask{getClassEnv}
    together with some Haskell type class instances:

    \begin{haskellcode}
    type ClassEnv = Map Name ([Name], [TH.InstanceDec])

    -- | Given a list of class names iteratively find new classes
    -- mentioned in either the constraints of a class name or in any of
    -- the instances. Returns the `ClassEnv' with information about all
    -- instances for the initial classes and the discovered classes.
    getClassEnv :: [Name] -> TH.Q ClassEnv

    class Functor f => Applicative f where
        pure :: a -> f a

    instance             Applicative [a]
    instance Monoid a => Applicative ((,) a)

    class Monoid a

    instance             Monoid [a]
    instance Monoid a => Monoid (Maybe a)
    \end{haskellcode}

    For instance, lets say that a user includes the function
    \inlhask{pure :: Applicative f => a -> f a} as a constructor in
    the language. If this is the only function in the language
    containing a type class constraint the initial list of names $ns$
    will be \inlhask{[Applicative]}. The algorithm proceeds as
    follows:

    - Initialize a class environment $cenv$ to the empty set.
    - Loop until $ns$ is empty:
      1. Remove the first name $n$ from $ns$ and ask Template Haskell
         about the superclasses $sups$ and instances $is$ of $n$.
      2. Extend $cenv$ by adding a mapping from $n$ to $is$.
      3. Extend $ns$ by adding all type classes in $sups$ that is not
         yet mentioned in neither $ns$ nor $cenv$.
      4. Extend $ns$ by adding all type classes mentioned in any of
         the instances in $is$ but that is not yet mentioned in
         neither $ns$ nor $cenv$.
    - Return $cenv$

    In our example with \inlhask{[Applicative]} as the starting list,
    we would start by finding all information about
    \inlhask{Applicative} and adding \inlhask{Functor} and
    \inlhask{Monoid} to $ns$.[fn:4] The next step would be looking up
    the information of, for instance, \inlhask{Monoid}. Since there
    are no superclasses for this class then only classes mentioned in
    the instances are added. In this case, one of the instances
    mentions a class which is already in $cenv$, \inlhask{Monoid}, and
    this particular class is therefore not added to $ns$ since there
    is no need to recalculate the mapping for this name.[fn:5]

    The algorithm above is the most straightforward way known to the
    author to find all information about the type classes possibly
    used when generating values. However, the proposed algorithm has
    some problems when applied to, for instance, the list
    \inlhask{[Num]}. The resulting class environment is calculated
    very quickly but then compiling this value again in a Haskell
    takes up to a minute on a fairly modern computer. The reason is
    that GHC adds a lot of type classes not normally visible in a
    normal ghci session. The text representation of the final value
    that is spliced into the resulting file is around 700000
    characters long \todo{recheck this value}! Compiling such a large
    expression can take up to one minute or more even on a modern
    computer.

    In future versions of this library, the fourth step should be
    added again. However, some care has to be taken to only include
    classes that are relevant to the current problem. Possible ways to
    solve this is discussed further in section \ref{fut-CE}.

** ExpGen
   The =ExpGen= module contains the core algorithm and methods to
   generate type-safe expressions. The generation starts in the
   appropriately named function =generate= which works by finding
   matching =Constructor='s for the current goal type and recursively
   tries to generate expressions of the argument types used in the
   constructor. However, this is not as trivial as the above
   description makes it sound like and the following section explains
   the design choices and the different invariants used when
   implementing the complete algorithm.

*** The ExpGen state
*** Unique types
*** Match function
    \label{match}

*** Selecting a random matching constructor
    \label{random}

*** Generating expressions

\newpage

* Limitations
  Due to time limitations the scope and complexity of the project was
  reduced by limiting the implementation of the final project. This
  chapter discusses all these limitations and how they affect the
  final product. Further, each subsection contains a short discussion
  about how one might extend the library to eliminate the limitation.

** Expression type
   \label{lim-expressions}

** Type matching
** Rank >1 types
** Class environments
** Type variable arguments
   \label{lim-typearg}

** Equality constraints

\newpage

* Example usage
** Simple usage
** a Do-it-yourself High-Assurance compiler
** Feldspar

\newpage

* Future Work
** Class Environments
   \label{fut-CE}

** More expressions in =defineLanguage=
   \label{fut-defineLanguage}

   \newpage

* Related work

\newpage

* Conclusions

\newpage

\section*{References}

# Mark all references as cited
  \nocite{*}

  \printbibliography[heading=none]

* Footnotes

[fn:1] Also note that in this example you cannot use the name "List"
for the list type constructor since a user might add this data type
themselves.

[fn:2] For instance =lookupSubst :: Nat -> Substitution -> Maybe
([Variable], SType)= and \hbox{\tt (|->) :: Nat -> SType -> Substitution}

[fn:3] =Seed= is simply a type alias for an integer.

[fn:4]  \inlhask{Functor} is a superclass of \inlhask{Applicative}
while \inlhask{Monoid} is mentioned in one of the instances.

[fn:5] Further, adding \inlhask{Monoid} to $ns$ again would cause an
infinite loop.
