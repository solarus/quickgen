#+TITLE:
#+AUTHOR:    David Spångberg
#+EMAIL:     david@tunna.org
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+LATEX_HEADER: \usepackage[margin=3.5cm]{geometry}
#+LATEX_HEADER: \usepackage{lipsum, minted, xcolor, fancyhdr, xspace}
#+LATEX_HEADER: \usepackage[style=alphabetic,citestyle=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{references.bib}

# #### Palatino font
#+LATEX_HEADER: \usepackage[sc]{mathpazo}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \linespread{1.05} % Palatino needs more leading (space between lines)

#+BEGIN_LATEX
\hyphenation{testing}
\hyphenation{abstract}
\hyphenation{optimizations}
\hyphenation{successfully}

\setlength{\parskip}{0.2cm}
\setlength{\parindent}{0pt}

\newcommand{\quickgen}[0]{\textsc{QuickGen}\xspace}
\newcommand{\note}[1]{{\color{blue} Note: \emph{#1}}}
\newcommand{\todo}[1]{{\color{red} TODO: \emph{#1}}}

\newminted{haskell}{linenos}
\newcommand{\inlhask}[1]{\mintinline{haskell}?#1?}

%%% Front page
\thispagestyle{empty}
\begin{center}
\includegraphics{logo_gu.eps}

\vspace{2cm}

\hrule \bigskip
{\Huge API-driven generation of well-typed terms} \bigskip
\hrule

\vspace{1.5cm}

{\Large Master Thesis Project}

\vspace{5cm}

\Large David Spångberg \texttt{<davspa@student.gu.se>} \bigskip

\today
\end{center}

\newpage
#+END_LATEX

\pagestyle{empty}

\vspace*{3.5cm}

\begin{center}
\textbf{\large{Abstract}}
\end{center}

\todo{Skriv abstract!}

\newpage

#+TOC: headlines 3

\newpage

\lhead{\emph \rightmark}
\rhead{\emph \leftmark}
\pagestyle{fancy}

\setcounter{page}{1}

* Problem background
  \note{Flytta delar till abstract respektive intro}

  When developing a compiler for a Domain Specific Language (DSL) one
  often want to test certain aspects of the compiler. For instance,
  testing that the result of evaluating an expression produces the
  same result both before and after certain optimizations. One way to
  achieve this is to design unit tests that cover all developed
  optimizations. This approach has several limitations. For instance,
  when new optimizations are added, new unit tests have to be
  developed. Similarly, when optimizations are modified, the
  corresponding unit tests have to be updated.

  Instead, when testing compilers, it might be possible to construct a
  generator for random Abstract Syntax Trees (AST) of the given
  language and use this generator to test the optimizations. However,
  these ASTs might have several invariants and constructing a
  generator producing only valid ASTs might be non-trivial. One
  solution to this problem is to only use smart constructors given by
  an API to produce values of the requested type. However, combining
  these smart constructors in a sensible way might be equally
  non-trivial.

  Aspects of the compiler other than optimizations can also be tested
  in similar ways. One example is testing that interpreting a program
  versus compiling and executing it produces the same result. This
  test and several others has similar preconditions as the
  optimization tests, it requires that a program is somehow generated
  or constructed before the test in question can finish.

\newpage

* Introduction
** Problem description
** Literature

\newpage

* Implementation
  In this chapter the current implementation is explained thoroughly.
  First the data types used to represent, for instance, types and
  values is presented together with the functions used to work with
  the respective data types. Some of the limitations imposed by the
  specific representation scheme for the types presented is also
  discussed. After this a brief presentation of the template haskell
  part of the library is discussed and some examples are presented.

  Finally, the implementation of the code generation and matching is
  presented thoroughly. Initially a high level description of the
  implementation is presented together with a explanation of how the
  different functions fit together. Later the most important functions
  are presented in detail. This is done by reasoning about several
  edge-cases, invariants and the actual implementation of the
  functions in question.

** Types and expressions
*** Variables, Forall and Undecided
    \label{variables}

    In Haskell a type can contain forall quantified type variables.
    For instance in the type for \inlhask{id :: a -> a} an implicit
    forall for the type variable =a= is introduced resulting in the
    final type \inlhask{id :: forall a. a -> a}. This type says that
    \inlhask{id} works for *any* type =a=, be it integers, list of
    strings or functions containing their own forall quantified type
    variables. \quickgen introduces another kind of quantifier,
    \inlhask{Undecided}. Basically, an undecided variable is
    introduced during type matching when a forall quantified variable
    has nothing to do with the matched type. Lets consider an example:

    A user wants to generate some expression of type \inlhask{[Int]}
    and \inlhask{map :: (a -> b) -> [a] -> [b]} is one of the
    available functions in the user API. When these types reach the
    matching function the matching proceeds by only considering the
    return type of \inlhask{map}, \inlhask{[b]}. The matching succeeds
    and a substitution from \inlhask{Int} to =b= and the current
    matched type now looks like: \inlhask{map :: (a -> Int) -> [a] ->
    [Int]}. As you can see, the type =a= does not have anything to do
    with the matched type \inlhask{[Int]} and can therefore be any
    type. It can be a forall quantified type variable or it can be a
    more specilized type, for instance \inlhask{[Double]}. In this
    case the matching algorithm will therefore return something
    similar to: \inlhask{map :: undecided a. (a -> Int) -> [a] ->
    [Int]}.

    With these explanations we can now look at how \quickgen encodes
    type variables internally:

    \begin{haskellcode}
    data Quantifier = Forall | Undecided
    type Nat = Int
    type Variable = (Nat, Quantifier)
    \end{haskellcode}

    Simply put, instead of storing the name of a type variable as a
    string, a natural number is used instead. This is done for
    performance reasons and is explained more in section \ref{match}.
    Finally, the quantifier for the variable is also included in the
    \inlhask{Variable} type alias.

*** Constructors
    \label{constructors}

    A constructor is the term used for the haskell functions found in
    the specified user API. The intuition is that one of these terms
    can be used to construct parts of an haskell expression. The
    internal representation of a constructor is very simple:

    \begin{haskellcode}
    type Name = TH.Name
    type Constructor = (Name, Type)
    \end{haskellcode}

    A \inlhask{Name} is simply a type alias for names in Template
    Haskell \cite{TH}. A \inlhask{Type} corresponds to the, possibly
    specialized, type of the constructor. Types are discussed in the
    next section and how to a specialize a type for a constructor is
    explained in section \ref{TH}.

*** Types and simple types
    Below are the two data types in \quickgen that are used to
    represent types in Haskell:

    \begin{haskellcode}
    data Type = Type [Variable] Cxt SType
    \end{haskellcode}

    \begin{haskellcode}
    data SType =
        FunT [SType]
      | VarT Variable
      | ConT Name [SType]
      | ListT SType
    \end{haskellcode}

    The first data type is used to introduce variables, and
    constraints on these variables, in types. The second data type
    =SType= has constructors for representing functions, variables,
    constructors \ref{constructors} and lists. For instance the the
    implicitly forall quantified type \inlhask{a -> b -> b} could be
    represented as

    \begin{haskellcode}
    Type [(0, Forall), (1, Forall)] [] (FunT [ VarT (1, Forall)
                                             , VarT (1, Forall)
                                             , VarT (0, Forall)
                                             ])
    \end{haskellcode}

    The name of a type variable are turned into a natural number and a
    quantifier (here Forall) as explained in \ref{variables} . The
    type variable =a= is here turned into \inlhask{(0, Forall)} and
    =b= is turned into \inlhask{(1, Forall)}. A not so obvious
    transformation is done for the inner =SType=. The order of the
    type variables in the function type is reversed if you compare to
    the original type. The reason this is done is to make the
    implementation of the type matching more efficient. This is
    discussed in section \ref{match}. For now, it is enough to
    remember that function types are reversed.

    The rest of the constructors, \inlhask{VarT, ConT} and
    \inlhask{ListT} represents type variables, type constructors and
    lists respectively. The observant reader may notice that there is
    currently no way to represent type variables with arguments, i.e.
    there is no way to represent the type of \inlhask{return :: Monad m => a -> m a}
    This limitation and ways to solve it are discussed further in
    section \ref{lim-typearg}.

    The reason there is an extra constructor \inlhask{ListT} for lists
    instead of representing them as \inlhask{ConT "List" a} [fn:1] is
    just a convenience which make the implementation simpler, it also
    follows the representation for types used in Template Haskell
    \cite{TH}.

*** Expressions
*** Other types
**** Languages
**** Contexts
**** Substitutions
**** Class environments
**** Equality constraints
** Template Haskell
   \label{TH}

   The library contains a small module =TH= with one exported Template
   Haskell function =defineLanguage= that an user can use to construct
   a =Language=.

   \todo{Discuss todo in getClassEnv.}

** ExpGen
   The =ExpGen= module contains the core algorithm and methods to
   generate type-safe expressions. The generation starts in the
   appropriately named function =generate= which works by finding
   matching =Constructor='s for the current goal type and recursively
   tries to generate expressions of the argument types used in the
   constructor. However, this is not as trivial as the above
   description makes it sound like and the following section explains
   the design choices and the different invariants used when
   implementing the complete algorithm.

*** The ExpGen state
*** Unique types
*** Match function
    \label{match}

*** Selecting a random matching constructor
*** Generating expressions

\newpage

* Limitations
  Due to time limitations the scope and complexity of the project was
  reduced by limiting the implementation of the final project. This
  chapter discusses all these limitations and how they affect the
  final product. Further, each subsection contains a short discussion
  about how one might extend the library to eliminate the limitation.

** Type matching
** Rank >1 types
** Class environments
** Type variable arguments
   \label{lim-typearg}

\newpage

* Example usage
** Simple usage
** a Do-it-yourself High-Assurance compiler
** Feldspar

\newpage

* Future Work

\newpage

* Related work

\newpage

* Conclusions

\newpage

\section*{References}

# Mark all references as cited
  \nocite{*}

  \printbibliography[heading=none]

* Footnotes

[fn:1] Also note that in this example you cannot use the name "List"
for the list type constructor since a user might add this data type
themselves.
