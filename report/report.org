#+TITLE:
#+AUTHOR:    David Spångberg
#+EMAIL:     david@tunna.org
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+LATEX_HEADER: \usepackage[margin=3.5cm]{geometry}
#+LATEX_HEADER: \usepackage[usenames,dvipsnames]{xcolor}
#+LATEX_HEADER: \usepackage{lipsum, minted, fancyhdr, xspace, algpseudocode, algorithm, mathtools}
#+LATEX_HEADER: \usepackage{ifdraft}
#+LATEX_HEADER: \usepackage[style=alphabetic,citestyle=alphabetic]{biblatex}
#+LATEX_HEADER: \addbibresource{references.bib}
#+LATEX_CLASS_OPTIONS: [draft]

# #### Palatino font
#+LATEX_HEADER: \usepackage[sc]{mathpazo}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \linespread{1.05} % Palatino needs more leading (space between lines)

#+BEGIN_LATEX
\hyphenation{testing}
\hyphenation{abstract}
\hyphenation{optimizations}
\hyphenation{successfully}

\setlength{\parskip}{0.2cm}
\setlength{\parindent}{0pt}

\newcommand{\quickgen}[0]{\textsc{QuickGen}\xspace}
\newcommand{\note}[1]{{\color{blue} \textbf{Note:} \emph{#1}}}
\newcommand{\todo}[1]{{\color{red} \textbf{TODO:} \emph{#1}}}

\newminted{haskell}{linenos}
\ifdraft
  {\newcommand{\inlhask}[1]{\mbox{\texttt{\color{purple}#1}}}}
  {\newcommand{\inlhask}[1]{\mintinline{haskell}?#1?}}


% It is probably possible to do this without having a -3pt hspace.
% There probably even exists such a library or command that does what
% I want.
\newenvironment{mycitation}
  { \begin{center}\begin{minipage}{\textwidth-2cm}%
    \em \hspace{0.5cm} "\hspace{-3pt}%
  }
  {\hspace{-3pt}"%
    \end{minipage}\end{center}
  }

\newenvironment{todo*}
  {\color{red} \textbf{TODO:} \em}
  {}

\newcommand{\ri}[0]{\rightarrow}

%%% algpseudocode switch statement
\algnewcommand\algorithmicswitch{\textbf{case}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\Raise[1]{\textbf{raise}\ \texttt{#1}}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
\algdef{Se}[CASEOF]{CaseOf}{EndCaseOf}[1]{\algorithmicswitch\ #1\ \textbf{of}}
\algdef{Se}[CASE]{Case}{EndCase}[1]{#1\ \textbf{then}}
\algdef{Se}[CASEELSE]{CaseElse}{EndCase}[0]{\textbf{else}}
\algtext*{EndCaseOf}
\algtext*{EndCase}%
\algtext*{EndIf}
\algtext*{EndFor}

%%% Example stuff
\newcounter{myexample}[section]
\numberwithin{myexample}{section}
\newcommand{\example}{\refstepcounter{myexample}\textbf{Example} \themyexample:\xspace}
\newcommand{\examplelabel}[1]{\example\label{#1}}

%%% Front page
\thispagestyle{empty}
\begin{center}
\includegraphics{logo_gu.eps}

\vspace{2cm}

\hrule \bigskip
{\Huge API-driven generation of well-typed terms} \bigskip
\hrule

\vspace{1.5cm}

{\Large Master Thesis Project}

\vspace{5cm}

\Large David Spångberg \texttt{<davspa@student.gu.se>} \bigskip

\today
\end{center}

\newpage
#+END_LATEX

\pagestyle{empty}

\vspace*{3.5cm}

\begin{center}
\textbf{\large{Abstract}}
\end{center}

\todo{Skriv abstract!}

\newpage

#+TOC: headlines 3

\newpage

\lhead{\emph \rightmark}
\rhead{\emph \leftmark}
\pagestyle{fancy}

\setcounter{page}{1}

* Introduction
  When developing a compiler for a Domain Specific Language (DSL) one
  often want to test certain aspects of the compiler. For instance,
  testing that the result of evaluating an expression produces the
  same result both before and after certain optimizations. One way to
  achieve this is to design unit tests that cover all developed
  optimizations. This approach has several limitations. For instance,
  when new optimizations are added, new unit tests have to be
  developed. Similarly, when optimizations are modified, the
  corresponding unit tests have to be updated.

  Instead, when testing compilers, it might be possible to construct a
  generator for random Abstract Syntax Trees (AST) of the given
  language and use this generator to test the optimizations. However,
  these ASTs might have several invariants and constructing a
  generator producing only valid ASTs might be non-trivial. One
  solution to this problem is to only use smart constructors given by
  an Application Programming Interface (API) to produce values of the
  requested type. However, combining these smart constructors in a
  sensible way might be equally non-trivial.

  Aspects of the compiler other than optimizations can also be tested
  in similar ways. One example is testing that interpreting a program
  versus compiling and executing it produces the same result. This
  test and several others has similar preconditions as the
  optimization tests, it requires that a program is somehow generated
  or constructed before the test in question can finish.

** Random generation
   Instead of creating a generator for an AST manually one might want
   to randomly generate expressions inside the AST by using functions
   from an API instead. This is valid since all meaningful terms in
   the AST should be describable somehow from the API provided by the
   DSL. What is missing is a procedure taking a number of functions,
   used to produce values within an AST, together with an additional
   goal type that should be the final type for the generated
   expression. This procedure could then be called repeatedly to find
   different random values of the goal type withing the AST. If
   functions is added or removed from the API, these functions only
   needs to be added respectively removed from the list of available
   functions supplied to the procedure. Furthermore, if the AST or the
   functions in the API is changed somehow, no changes is needed for
   the term generation procedure.

** Introducing QuickGen
   In this report the Haskell library \quickgen is presented, usable
   for producing higher order functional terms with polymorphic type
   variables. A /Language/ is simply defined in Template Haskell
   \cite{TH}, by specifying the functions and values available during
   term generation:

   \begin{haskellcode}
   lang :: Language
   lang = $(defineLanguage [| ( map   :: (a -> b) -> [a] -> [b]
                              , const :: a -> b -> a
                              , foldr :: (a -> b -> b) -> b -> [a] -> b
                              , nil   :: [a]
                              , cons  :: a -> [a] -> [a]
                              , n     :: Int
                              )
                            |])
   \end{haskellcode}

   A specific library function is responsible for generating
   expressions given a language:

   \begin{haskellcode}
   generate :: Language -> Type -> Seed -> Maybe Exp
   \end{haskellcode}

   A generator for terms of type \inlhask{a -> [a]} using
   \inlhask{lang} above can then be defined with the following
   definition:

   \begin{todo*}
   \textbf{a -> [a]} är låtsassyntax. Om tid finns fixa quasiquoter
   (bör vara lätt finns redan TH.Type quasiquoter och kan använda
   thTypeToType för att göra om till rätt representation) annars skriv
   riktiga syntaxen nedan.
   \end{todo*}

   \begin{haskellcode}
   f :: Seed -> Maybe Exp
   f seed = generate lang (a -> [a]) seed
   \end{haskellcode}

   Different seeds supplied to this functionthen produces different
   random well typed expressions using the available functions and
   values from \inlhask{lang}. The generated expressions can later be
   turned into real Haskell terms by using, for instance, the GHC API
   \cite{ghcapi}.

   \begin{todo*}
   Behöver testa quickgen på någonting ordentligt och skriva example
   usage först innan jag kan avsluta denna delsektion. Här vill jag
   skriva någonting i stil med: "Finally, \quickgen was successfully
   used to produce terms within a selection of haskell DSLs. These
   terms were in term used to correctly identify certain (artificially
   introduced?) flaws in the implementation of the language.
   \end{todo*}

** Related work

\newpage

* Algorithm
  This section is dedicated to the formal definition of the algorithm
  used to generate expressions from a user API. The first part
  contains an example run of the complete algorithm followed by
  discussion around some tricky parts. The last two subsections
  contains more formal explanations, with pseudo code, to the
  functions responsible for /type matching/ and /term generation/.

** A complete example
  \label{sec:example}

  Lets say an user wants to generate an expression of type $[Int]$
  using values and functions from the following API:

    #+NAME: table:api1
    #+CAPTION: Simple API
    |   | Constructor name | Type                        |
    |---+------------------+-----------------------------|
    | / |              <r> | <                           |
    |   |            $map$ | $(a \ri b) \ri [a] \ri [b]$ |
    |   |           $sing$ | $a \ri [a]$                 |
    |   |            $nil$ | $[a]$                       |
    |   |              $n$ | $Int$                       |
    |   |              $d$ | $Double$                    |

  The first step is choosing a random function or value where the
  return type matches our current goal type. In table \ref{table:api1}
  above, the term /constructor/ is used to refer to one of these
  functions or values that can be used by the algorithm to generate
  expressions[fn:10]. Just by looking at the available constructors,
  one finds that all but the last two values has return types that
  matches our current goal: $[Int]$. The constructors that do match
  however needs to be slightly specialized to exactly match our goal
  type.

  Lets say that we choose $map$ as the first random matching
  constructor. In this case, for $map$ to match our goal type of
  $[Int]$ the for all quantified type variable $b$ has to be
  instantiated to an $Int$. The other type variable, $a$, has nothing
  to do with the current goal and can therefore be instantiated to
  anything. We might at this point generate a random type for $a$
  based on the constructors in scope as is done in \cite{lambda}. Here
  another tactic is employed and we say that the type variable is
  /undecided/ instead. We will introduce the special notation $?a$ to
  mean exactly this, that the type variable $a$ is undecided. What
  this means is that the type of $a$ has not been specialized yet but
  might be in a later state of the generation algorithm. In the end,
  the final specialized type for $map$ that we arrive at is $(?a \ri
  Int) \ri [?a] \ri [Int]$.

  At this point, it might help to visualize the current expression as:
  \[ map~e_1~e_2 \] where $e_1$ and $e_2$ are two, as of yet, non
  generated expressions with types $(?a \ri Int)$ and $[?a]$
  respectively. To succeed, we need to generate these two new sub
  goals in some order instead. For simplicity's sake, lets do it from
  left to right starting with $e_1$:

  - \emph{Generating $e_1$ with type $?a \ri Int$}:

    At this point the algorithm differs slightly from the first step
    when generating $[Int]$ since we are currently trying to generate
    a function. In the end we want an expression on the form:
    \[\lambda x \ri body \] where the argument $x$ can be used inside
    $body$. To proceed all arguments are added as constructors to be
    available when generating the body of the lambda abstraction. In
    this case the only constructor added is $x ::\;?a$ resulting in
    the following set of constructors:

    #+NAME: table:api2
    #+CAPTION: Extended API
    |   | Constructor name | Type                        |
    |---+------------------+-----------------------------|
    | / |              <r> | <                           |
    |   |            $map$ | $(a \ri b) \ri [a] \ri [b]$ |
    |   |           $sing$ | $a \ri [a]$                 |
    |   |            $nil$ | $[a]$                       |
    |   |              $n$ | $Int$                       |
    |   |              $d$ | $Double$                    |
    |   |   $\color{red}x$ | $\color{red}?a$             |

    From here on the algorithm is exactly the same as for $[Int]$: a
    random matching constructor $\mathcal{C}$ is chosen and the
    arguments of $\mathcal{C},~y_1 \ldots y_n$, is recursively
    generated. If all arguments were successfully generated then
    $body$ would be equal to $\mathcal{C}~y_1~\ldots~y_n$ and the
    complete expression $e_1$ would be $(\lambda x \ri
    \mathcal{C}~y_1~\ldots~y_n)$.

    Here only the two constructors $n$ and $x$ match the current goal
    and are therefore the only candidates for $\mathcal{C}$. If we
    choose $\mathcal{C} = n$ then we return with $e_1 = (\lambda x \ri
    n)$ and continue generating $e_2 ::\;[?a]$. If we choose
    $\mathcal{C} = x$ then we return with $e_1 = (\lambda x \ri x)$
    but instead of continuing generating $e_2 ::\;[?a]$ as before we
    now need to generate $e_2 ::\;[Int]$, the reason being that in the
    original types of $e_1$ and $e_2$, $(?a \ri Int)$ and $[?a]$, the
    undecided type variable $?a$ refers to the same undecided type in
    both expressions. If we start generating $e_1$ and decide that
    $?a$ has to be an $Int$ then this change has to be present when we
    start generating $e_2$. To illustrate the difference both these
    cases will be considered below:

  - \emph{Case $e_1 = (\lambda x \ri n)$: Generating $e_2$ with type $[?a]$}:

    This time no new constructors are added to the API since we are
    not generating a function. The API at this point is therefore the
    one found in table \ref{table:api1}. Similar to before, the first
    three constructors is again the only ones matching the current
    goal. Lets assume the second one, $sing$, is chosen. The
    specialized type for $sing$ in this case would be $(?a \ri [?a])$
    and a new sub goal for an $?a$ is created. Here $?a$ can be
    matched with any constructor in the API but lets assume $d ::
    Double$ is chosen resulting in $e_2 = sing~d$. Since this is the
    last sub goal the term generation algorithm terminates with the
    complete expression $map~(\lambda x \ri n)~(sing~d)$.

  - \emph{Case $e_1 = (\lambda x \ri x)$: Generating $e_2$ with type $[Int]$}:

    Similar to the case for $[?a]$, no new constructors are added and
    the API is still the same as in table \ref{table:api1}. Lets
    assume that the first constructor chosen is the same as in the
    last step, $sing$. Here is where the difference in choice in $e_1$
    is visible when generating $e_2$. In the case above, all
    constructors matched the goal of $?a$. However, in this case $?a$
    has already been instantiated to a type, namely $Int$, when
    generating $e_1$. This forces us to choose $n$ as our constructor
    since no other ones match the current goal. Again, this terminates
    the algorithm and the final expression would be $map~(\lambda x
    \ri x)~(sing~n)$.

*** Undecided variables
   \label{sec:undecided}

   When generating $e_1$ in section \ref{sec:example} above, two
   different cases was considered. In the first one, the undecided
   variable $?a$ was left untouched. The second one showed that a
   guess or decision made for an undecided variable in one part needs
   to be reflected in the rest of the generation process. How this
   information about guesses for undecided variables should be handled
   is non trivial. Lets look at an example:

   \example Imagine we are generating a term of type $t$ using the
   following constructor: \[ c :: t_1 \ri \ldots \ri t_n \ri t \]
   Furthermore, assume the undecided variable $?a$ is somehow part of
   $c$, i.e. $?a$ is present in at least one, and potentially all, of
   the types $t_1, \ldots, t_n$ and $t$. If we start generating a sub
   goal, for instance $t_1$, we might select another constructor
   containing additional sub goals which in turn might introduce even
   more sub goals. At any point in any of these subtrees we might
   decide that $?a$ should have type $Int$. This information needs to
   propagate upwards somehow. One could try updating the API by
   exchanging every usage of $?a$ with $Int$. However, this does not
   solve the problem that $?a$ might be present in one of the sub
   goals at the same level or higher up. If the sub goals and
   intermediate constructors was saved on a stack one might traverse
   this stack updating the types for sub goals containing $?a$.
   However, this stack, and the API, might grow to be very large
   making it potentially hard to implement this operation efficiently.

   An alternative tactic that is employed in this project is to have a
   global set of guesses, $\mathbb{U}$, that is consulted before
   trying to generate a sub goal containing undecided variables. It is
   also consulted before trying to match a goal with a given
   constructor $c$ from the API since the type of $c$ might contain
   undecided variables. Finally, when a guess for an undecided
   variable is performed, this guess needs to be stored in
   $\mathbb{U}$.

*** Termination
    \label{algo:termination}

    There is one simplification to the simple algorithm presented
    above that needs to be mentioned. The algorithm if implemented
    directly is not guaranteed to terminate. Lets look at a very
    simple example:

    |   | Constructor name | Type      |
    |---+------------------+-----------|
    | / |              <r> |           |
    |   |             $id$ | $a \ri a$ |
    |   |              $n$ | Int       |

    Say that we want to generate a term of type $Int$. The generation
    algorithm might choose $id$ as the first constructor. After type
    matching and specialization we have exactly the same API and sub
    goal as in the original problem, we need to generate an $Int$. At
    this point there is nothing that stops the algorithm from choosing
    $id$ indefinitely making this a non terminating process. In this
    particular example, the probability of termination is quite high
    but this might not be the case if constructors requiring several
    sub goals to be generated is introduced to the API. A solution
    involving limiting the number of times constructors with sub goals
    is used is introduced in section \ref{algo:generate}. There is
    also some discussion about alternative termination strategies in
    section \ref{fut:termination}.

*** Sub goal ordering
    After choosing $map$ as the first constructor in the original
    algorithm in section \ref{sec:example}, we choose to generate the
    sub goals to $map$ from left to right. With the addition of uses
    as mentioned in section \ref{algo:termination} above, the order in
    which sub goals are generated actually influences the final shape
    of the finished expression. Again, lets illustrate this by looking
    at an example where we want to generate an expression with type
    $Int$ using the following API:

    #+CAPTION: API containing constructors with a limited number of uses
    |   | Constructor name | Uses     | Type            |
    |---+------------------+----------+-----------------|
    | / |              <r> |          |                 |
    |   |          $const$ | 2        | $a \ri b \ri a$ |
    |   |              $n$ | $\infty$ | $Int$           |

    As before, the API contains the constructors available for use
    when generating expressions. The difference this time is that a
    limited number of uses, here two, is also imposed on the first
    constructor. The second constructor, having no sub goals, can be
    seen having an infinite number of uses. If we start with the
    specialized constructor $const :: Int \ri ?b \ri Int$ we update
    the API by saying that $const$ now has one use left. From here, we
    can choose to generate either of the sub goals, $Int$ respectively
    $?b$. If we choose to generate from left to right starting with
    $Int$ and $const$ is our choice for constructor then we have
    effectively used up all usages of $const$ available in this run of
    the algorithm. This forces us to choose $n$ as a constructor in
    all remaining sub goals including in the goal for $?b$. If we go
    right to left instead, we may experience the same problem, i.e. we
    may limit the available constructors, and thereby forcing the
    shape of the finished expression.

    In general, if there are several constructors in the API
    containing at least one sub goal, the generated expressions are
    biased towards the direction of the first sub goals, i.e. if we
    start from the left, most usages of constructors will be present
    in the leftmost sub goals.

    Due to implementation details, the finished algorithm in this
    project generates goals from right to left making the expressions
    biased towards the right. In one of the sections in future work,
    section \ref{fut:ordering}, some alternative tactics regarding sub
    goal ordering is discussed.

** Matching expressions
   \label{algo:match}

   Type matching is the process of finding a minimal substitution for
   a type $t_1$ that makes it equal to a goal type $t_2$
   \cite[7--8]{syta}. For instance, imagine we have the following
   variables: \(x :: a \ri Int \ri b\) and \(y :: Int \ri Int \ri
   Bool\). If we try to match the type of \(x\) with \(y\) then the
   substitution \(\{ a \mapsto Int, b \mapsto Bool\} \) will be
   returned. If no match is found a failure is raised instead.

   The \textsc{Match} algorithm presented below is similar to regular
   type matching in the respect that it finds a substitution for the
   for all quantified type variables. However, there are some
   differences. Lets look at one example to see how it differs from
   normal type matching: \[ \textsc{Match}(Int,~a \rightarrow b)
   \Longrightarrow (?a \rightarrow Int) \] The first difference we see
   is that \textsc{Match} actually returns a new type instead of a
   substitution. \textsc{Match} did find a substitution but then
   immediately applied it to the second argument to produce a
   specialized type. Further, a normal type matching algorithm
   wouldn't find a substitution at all, it would fail on this
   particular input since a value type normally cannot normally be
   matched against a function. \textsc{Match} however returns the type
   $(?a \rightarrow Int)$.

   From the original type we can see that $b$ has been turned into
   $Int$ which might not be all that surprising. The type variable $a$
   however has lost its for all quantifier and been turned into an
   undecided type variable as explained in section \ref{sec:example}
   above. Further, the \textsc{Match} function only looks at the
   return type of the second argument during matching. Therefore, in
   this example, the only type variable considered during matching was
   $b$. All of the remaining for all quantified type variables, in
   this case $a$, will be turned into undecided type variables, here
   $?a$.

   The intuition is that the type $(a \rightarrow Int)$ can be used to
   construct a value of type $Int$ if we give it another value of type
   $a$. Since $a$ is for all quantified then a value of any type can
   be given to a function of this type for it to produce an $Int$
   value.

   With this small introduction it is time to look at the algorithm
   for the match function.

   \note{Some info about why the undecided set is needed below? Refer to Generate code?}

   - Let $\mathbb{U}$ be a set of guesses for undecided
     variables[fn:13]. Then the \textsc{Match} function takes two
     types, $t_1$ and $t_2$, and finds out if the type $t_2$ can be
     specialized in such a way that a value of this specialized type
     can be used in the construction of a value of type $t_1$. If
     $\textsc{Match}$ is successful, the specialized version of $t_2$
     is returned. In addition to returning the specialized type, the
     set of guesses might be updated during matching. If no match
     could be found then a failure is raised instead.

   \begin{algorithmic}[1]
   \Function{Match}{$t_1, t_2$}
     \If{$t_2$ is a function type $t_2 = x_1 \ri \ldots \ri x_n$}
       \State $s \gets \Call{MatchAux}{t_1, x_n}$
     \Else
       \State $s \gets \Call{MatchAux}{t_1, t_2}$
     \EndIf
     \\
     \State Update $t_2$ by applying the substitution $s$ to the type
     \State Update $t_2$ by converting all $Forall$ quantified types to $Undecided$ ones
     \\
     \State \Return{$t_2$}
   \EndFunction
   \end{algorithmic}

   The first step is trying to find a substitution that either makes
   $t_2$, or the return type of $t_2$, match $t_1$. If such a
   substitution is found then it is applied to $t_2$. The last step
   before returning $t_2$ is to make all $Forall$ quantified type
   variables into $Undecided$ ones. The algorithm that actually finds
   a substitution is found in the \textsc{MatchAux} function: [fn:12]

   \begin{algorithmic}[1]
   \Function{MatchAux}{$t_1, t_2$}
     \CaseOf{$t_2$}
       \Case{$\forall~b.~b$}
         \State \Return{$\{b \mapsto t_1\}$}
       \EndCase

       \Case{$\mathcal{C}(y_1, \ldots, y_n)$}
         \If{$t_1$ is not the same type constructor as $t_2$, i.e. $t_1 \neq \mathcal{C}(x_1, \ldots, x_n)$ \footnote{For some types $x_1 \ldots x_n$.}}
           \State \Raise{No\_Match}
         \Else
           \State \Return{$\bigcup_i~\Call{MatchAux}{x_i, y_i}$}
         \EndIf
       \EndCase

       \Case{$?b$}
         \If{$t_1 = t_2 = ?b$}
           \State \Return{$\emptyset$}
         \ElsIf{$?b \in \Call{Vars}{t_1}$}
           \State \Raise{No\_Match}
         \ElsIf{$\exists~t,~\text{s.t.}~(?b \mapsto t) \in \mathbb{U}$}
           \State \Return{\Call{MatchAux}{$t_1,t$}}
         \Else
           \State Add the mapping $(?b \mapsto t_1)$ to $\mathbb{U}$
           \State \Return{$\emptyset$}
         \EndIf
       \EndCase

       \CaseElse
         \CaseOf{$t_1$}
           \Case{$?a$}
             \LineComment{Similar to the case for $?b$ except in the last \textbf{else}}
             \State{\ldots}
             \CaseElse
               \State Convert all $\forall$ type variables in $t_2$ to undecided
               \State Add the mapping $(?a \mapsto t_2)$ to $\mathbb{U}$
               \State \Return{$\emptyset$}
             \EndCase
           \EndCase

           \CaseElse
             \State \Raise{No\_Match}
           \EndCase
         \EndCaseOf
       \EndCase
     \EndCaseOf
   \EndFunction
   \end{algorithmic}

   Lets look at an example of how the complete algorithm works:

   - Let $t_1 = [Int]$ and $t_2 = (a \ri b)\ri[a]\ri[b]$.
     \textsc{Match} will proceed by trying to find a substitution for
     $[Int]$ and the return type of $t_2$ [fn:9], namely $[b]$.
     - In \textsc{MatchAux} the second case will match with
       $\mathcal{C}=[\,]$ and $y_1=b$. Since $t_1$ is also of this
       form, $\mathcal{C}=[\,]$ and $x_1=Int$, then
       \textsc{MatchAux}$(Int, ~b)$ will be called recursively.
     - Now since the second argument is for all quantified, the
       singleton substitution $\{b~\mapsto~Int\}$ is returned. This is
       also the value returned to \textsc{Match}.
   - The substitution returned from \textsc{MatchAux} is applied to
     $t_2 = ~(a \ri b) \ri [a] \ri [b]$ resulting in $(a \ri Int) \ri
     [a] \ri [Int]$.
   - In the last step the remaining for all quantified variable is
     turned into an undecided one and $(?a \ri Int) \ri [?a] \ri
     [Int]$ is returned.

*** Unique types
    One important property which has been left out of the discussion
    so far is that all undecided type variables introduced in
    \textsc{Match} is assumed to be unique. Lets look at an example to
    explain this:

    \example Imagine we are generating a value with type $[ [Int] ]$
    using the API found in table \ref{table:api1}. Lets further
    imagine that the final generated expression is the following: \[
    map~(\lambda xs \ri map~(\lambda x \ri x)~xs)~[ [n] ] \] If we
    follow the general algorithm introduced in section \ref{sec:example}
    in minute detail we would use the same undecided type variable
    $?a$ for both uses of $map$. Then if we start generating the
    second argument to the outer $map$ the mapping $(?a \mapsto
    [Int])$ would be added to $\mathbb{U}$. Now since both $xs$ and
    $x$ has type $?a$, both of these values will be specialized to
    $[Int]$ which is not what we want! In this particular example, the
    inner anonymous function $(\lambda x \ri x)$ would not even pass
    the type checker.

    A simple way to solve this is to exchange every for all quantified
    type variable in a type $t$ with a natural number before supplying
    $t$ as the second argument to \textsc{Match}. Start with $n := 0$
    which represents the next unique natural number to be used in a
    type. Then the general procedure is as follows:

    - For some type $t$ find the set of for all quantified type
      variables encountered in $t$: \[ \textsc{Vars}(t) = \{
      a_1,\ldots,a_m \}\]
    - Create the substitution $s = \{a_1 \mapsto n , \ldots, a_m
      \mapsto n+m-1\}$
    - Let $n := n + m$
    - Update $t$ by applying the substitution $s$ to $t$

    At this point every type variables in $t$ is unique for the entire
    run of the algorithm since it isn't legal to have natural numbers
    as types in standard Haskell. This makes it completely safe to
    introduce mappings for undecided variables in $\mathbb{U}$ in
    \textsc{MatchAux}.

** Generating expressions
   \label{algo:generate}

   Let $uses$ be some natural number, $\Gamma$ a context and
   $\mathbb{U}$ a set of guesses for undecided type variables, then
   the generation algorithm works as follows:

   \begin{algorithmic}[1]
   \Function{Generate}{$t$}
     \State Bind all $\forall$ quantified variables in $t$ to some unique Data constructor types.
     \Comment{\emph{If for instance $t = a \rightarrow b$
     then the resulting type might be $A1 \rightarrow B2$}}
     \State \textbf{return} \Call{Generate'}{$t$}
   \EndFunction
   \end{algorithmic}

   \newpage

   \note{On line 18 it might be easy to miss that $t$ is the same $t$ as on line 1} \\
   \note{Consider moving to appendix}

   \begin{algorithmic}[1]
   \Function{Generate'}{$t$}
     \If{$t$ is a function type $t_1 \rightarrow \ldots \rightarrow t_m$}
       \State Generate unique variable names $x_1, \ldots, x_{m-1}$
       \State Add the constructors $(uses, (x_i, t_i)),~1 \leq i < m$ to \Gamma$
       \State $v \gets$ \Call{Generate'}{$t_m, \Gamma$}
       \State Remove the $x_i,~1 \leq i < m$ constructors from $\Gamma$
       \If{$v$ is \texttt{Just} an expression}
         \State \textbf{return} $(\lambda x_1~x_2~\ldots~x_{m-1} \rightarrow v)$
       \Else \Comment{$v$ is here \texttt{Nothing}}
         \State \textbf{return} \texttt{Nothing}
       \EndIf
     \Else \Comment{$t$ is here a value type}
       \State $\mathbb{U}' \gets \mathbb{U}$
       \State $\Gamma' \gets \Gamma$

       \State $c \gets$ A random matching constructor with positive uses in $\Gamma$
       \Comment{\emph{This line might introduce guesses for undecided type variables}}

       \If{$c$ is \texttt{Just} a constructor $c = (n, t')$}
         \State decrease the number of uses for $c$ in $\Gamma$ by one
         \If{$t' = t_1 \rightarrow \ldots \rightarrow t_m \rightarrow t$}
           \ForAll{$1 \leq i \leq m$}
             \State $e_i \gets$ \Call{Generate'}{$t_i, \Gamma$}
           \EndFor
           \If{$\exists~i,~e_i = $ \texttt{Nothing}}
             \State $\Gamma := \Gamma'$
             \State $\mathbb{U} := \mathbb{U}'$
             \State \textbf{return} \texttt{Nothing}
           \Else
             \State \textbf{return} \texttt{Just} $(n~e_1~\ldots~e_m)$
           \EndIf
         \Else \Comment{$c$ has here a value type}
           \State \textbf{return} \texttt{Just} the name of the constructor $c$
         \EndIf
       \Else \Comment{$c$ is here \texttt{Nothing}}
         \State \textbf{return} Nothing
       \EndIf
     \EndIf
   \EndFunction
   \end{algorithmic}

* Implementation
  In this chapter the current implementation is explained thoroughly.
  First the data types used to represent, for instance, types and
  values is presented together with the functions used to work with
  the respective data types. Some of the limitations imposed by the
  specific representation scheme for the types presented is also
  discussed. After this a brief presentation of the template haskell
  part of the library is discussed and some examples are presented.

  Finally, the implementation of the code generation and matching is
  presented thoroughly. Initially a high level description of the
  implementation is presented together with a explanation of how the
  different functions fit together. Later the most important functions
  are presented in detail. This is done by reasoning about several
  edge-cases, invariants and the actual implementation of the
  functions in question.

** Types and expressions
*** Variables, Forall and Undecided
    \label{variables}

    In Haskell a type can contain for all quantified type variables.
    For instance in the type for \inlhask{id :: a -> a} an implicit
    for all for the type variable =a= is introduced resulting in the
    final type \inlhask{id :: forall a. a -> a}. This type says that
    \inlhask{id} works for *any* type =a=, be it integers, list of
    strings or functions containing their own for all quantified type
    variables. \quickgen introduces another kind of quantifier,
    \inlhask{Undecided}. Basically, an undecided variable is
    introduced during type matching when a for all quantified variable
    has nothing to do with the matched type. Lets consider an example:

    A user wants to generate some expression of type \inlhask{[Int]}
    and \inlhask{map :: (a -> b) -> [a] -> [b]} is one of the
    available functions in the user API. When these types reach the
    matching function the matching proceeds by only considering the
    return type of \inlhask{map}, \inlhask{[b]}. The matching succeeds
    and a substitution from \inlhask{Int} to =b= and the current
    matched type now looks like: \inlhask{map :: (a -> Int) -> [a] -> [Int]}.
    As you can see, the type =a= does not have anything to do with the
    matched type \inlhask{[Int]} and can therefore be any type. It can
    be a for all quantified type variable or it can be a more
    specilized type, for instance \inlhask{[Double]}. In this case the
    matching algorithm will therefore return something similar to:
    \inlhask{map :: undecided a. (a -> Int) -> [a] -> [Int]}.

    With these explanations we can now look at how \quickgen encodes
    type variables internally:

    \begin{haskellcode}
    data Quantifier = Forall | Undecided
    type Nat = Int
    type Variable = (Nat, Quantifier)
    \end{haskellcode}

    Simply put, instead of storing the name of a type variable as a
    string, a natural number is used instead. This is done for
    performance reasons and is explained more in section \ref{match}.
    Finally, the quantifier for the variable is also included in the
    \inlhask{Variable} type alias.

*** Constructors
    \label{constructors}

    A constructor is the term used for the haskell functions found in
    the specified user API. The intuition is that one of these terms
    can be used to construct parts of an haskell expression. The
    internal representation of a constructor is very simple:

    \begin{haskellcode}
    type Name = TH.Name
    type Constructor = (Name, Type)
    \end{haskellcode}

    A \inlhask{Name} is simply a type alias for names in Template
    Haskell \cite{TH}. A \inlhask{Type} corresponds to the, possibly
    specialized, type of the constructor. Types are discussed in the
    next section and how to a specialize a type for a constructor is
    explained in section \ref{TH}.

*** Types and simple types
    Below are the two data types in \quickgen that are used to
    represent types in Haskell:

    \begin{haskellcode}
    data Type = Type [Variable] Cxt SType

    data SType =
        FunT [SType]
      | VarT Variable
      | ConT Name [SType]
      | ListT SType
    \end{haskellcode}

    The first data type is used to introduce variables, and
    constraints on these variables, in types. The second data type
    =SType= has constructors for representing functions, variables,
    constructors \ref{constructors} and lists. For instance the the
    implicitly for all quantified type \inlhask{a -> b -> b} could be
    represented as

    \begin{haskellcode}
    Type [(0, Forall), (1, Forall)] [] (FunT [ VarT (1, Forall)
                                             , VarT (1, Forall)
                                             , VarT (0, Forall)
                                             ])
    \end{haskellcode}

    The name of a type variable are turned into a natural number and a
    quantifier (here Forall) as explained in \ref{variables} . The
    type variable =a= is here turned into \inlhask{(0, Forall)} and
    =b= is turned into \inlhask{(1, Forall)}. A not so obvious
    transformation is done for the inner =SType=. The order of the
    type variables in the function type is reversed if you compare to
    the original type. The reason this is done is to make the
    implementation of the type matching more efficient. This is
    discussed in section \ref{match}. For now, it is enough to
    remember that function types are reversed.

    The rest of the constructors, \inlhask{VarT, ConT} and
    \inlhask{ListT} represents type variables, type constructors and
    lists respectively. The observant reader may notice that there is
    currently no way to represent type variables with arguments, i.e.
    there is no way to represent the type of \inlhask{return :: Monad m => a -> m a}
    This limitation and ways to solve it are discussed further in
    section \ref{lim-typearg}.

    The reason there is an extra constructor \inlhask{ListT} for lists
    instead of representing them as \inlhask{ConT "List" a} [fn:1] is
    just a convenience which make the implementation simpler, it also
    follows the representation for types used in Template Haskell
    \cite{TH}.

*** Expressions
    The following data type is used for the generated expressions in
    \quickgen:

    \begin{haskellcode}
    data Exp =
        ConE Name
      | AppE Exp Exp
      | LamE [Name] Exp
    \end{haskellcode}

    An expression is either the name of a \inlhask{Constructor}
    \ref{constructors}, an expression applied to another expression or
    a lambda expression. The list of \inlhask{Name}'s in a lambda
    expression will always be non empty. This data types is very
    simple when compared to the expression data type used by Template
    Haskell \cite{TH}. However, this means that some haskell
    expressions, like case- and let-expressions, cannot be generated
    by the library. This limitation and why this has little effect on
    the usability of the library is discussed more in section
    \ref{lim-expressions}.

*** Other types
**** *Substitutions:*
     \label{types-subst}

     \todo{Elaborate on Undecided type variables.}

     A mapping from type identifiers, natural numbers, to simple
     types, \inlhask{SType}'s. There is a value of this type in the
     state when generating expressions. This value only contain
     mappings for \inlhask{Undecided} variables since the
     \inlhask{Forall} quantified variables has already been bound. The
     \inlhask{Types} module contains several functions [fn:2] for
     transforming and getting information from
     \inlhask{Substitution}'s.

**** *Contexts* and *Uses*:
     A \inlhask{Context} is a mapping from type identifiers to
     constructors paired together with the available \inlhask{Uses}
     left for each particular constructor.

     \begin{haskellcode}
     type Uses = Maybe Nat
     type Context = Map Id (Uses, Constructor)
     \end{haskellcode}

     The number of uses can either be \inlhask{Just} a natural number
     or \inlhask{Nothing}, the latter indicating that this particular
     constructor can be used an unlimited number of times. Further
     discussion relating to \inlhask{Uses} can be found in section
     \ref{random}.

**** *Class environments:*
     A mapping from names of Haskell type classes to a list of super
     classes paired with the Template Haskell instance declaration.

     \begin{haskellcode}
     type ClassEnv = Map Name ([Name], [TH.InstanceDec])
     \end{haskellcode}

     Currently the class environment is not used internally apart from
     being constructed in the Template Haskell module. Future work
     regarding the usage of this type is discussed in section
     \ref{fut-CE}.

**** *Languages:*
     \label{types-languages}

     Basically a \inlhask{ClassEnv} paired together with a list of
     \inlhask{Constructor}'s. A \inlhask{Language}'s is one of the
     arguments for the library function \inlhask{generate}, the other
     two being a \inlhask{Type} and a \inlhask{Seed} [fn:3]. The
     \inlhask{generate} function together with a value of these three
     types are the only thing a user needs to generate well-typed
     terms using this library. Currently the only way for an end user
     to construct a value of this type is via the Template Haskell
     function \inlhask{defineLanguage}.

** Template Haskell
   \label{TH}

   \begin{todo*}
   This section is too damn long! Maybe only keep the pseudocode and
   move parts to future work section
   \end{todo*}

   The library contains a small module =TH= with one exported Template
   Haskell function =defineLanguage= that an user can use to construct
   a =Language=. Below follows an example usage of this function:

   \begin{haskellcode}
   genInt = 0 :: Int
   nil  = []
   cons = (:)

   lang :: Language
   lang = $(defineLanguage [| ( genInt, nil, cons
                              , id, map
                              ) |])
   \end{haskellcode}

   As you might suspect, it is currently not possible to directly
   include \inlhask{(:)} and \inlhask{[]}, the only thing that is
   accepted is names of functions. How one might possibly add this
   functionality is discussed in section \ref{fut-defineLanguage}.

   There is also one additional form when specifying API functions:

   \begin{haskellcode}
   $(defineLanguage [| (map :: (a -> Int) -> [a] -> [Int], id) |])
   \end{haskellcode}

   This specializes the type of \inlhask{map} so that it can only be
   used to construct expressions of type \inlhask{[Int]}.

*** Calculating a class environment
    As mentioned in section \ref{types-languages}, a
    \inlhask{Language} is isomorphic to a \inlhask{ClassEnv} paired
    with a list of \inlhask{Constructor}'s. The easiest way to explain
    how a class environment is calculated is probably by presenting
    the documentation for the internal function \inlhask{getClassEnv}
    together with some Haskell type class instances:

    \begin{haskellcode}
    type ClassEnv = Map Name ([Name], [TH.InstanceDec])

    -- | Given a list of class names iteratively find new classes
    -- mentioned in either the constraints of a class name or in any of
    -- the instances. Returns the `ClassEnv' with information about all
    -- instances for the initial classes and the discovered classes.
    getClassEnv :: [Name] -> TH.Q ClassEnv

    class Functor f => Applicative f where
        pure :: a -> f a

    instance             Applicative [a]
    instance Monoid a => Applicative ((,) a)

    class Monoid a

    instance             Monoid [a]
    instance Monoid a => Monoid (Maybe a)
    \end{haskellcode}

    For instance, lets say that a user includes the function
    \inlhask{pure :: Applicative f => a -> f a} as a constructor in
    the language. If this is the only function in the language
    containing a type class constraint the initial list of names $ns$
    will be \inlhask{[Applicative]}. The algorithm proceeds as
    follows:

    - Initialize a class environment $cenv$ to the empty set.
    - Loop until $ns$ is empty:
      1. Remove the first name $n$ from $ns$ and ask Template Haskell
         about the superclasses $sups$ and instances $is$ of $n$.
      2. Extend $cenv$ by adding a mapping from $n$ to $is$.
      3. Extend $ns$ by adding all type classes in $sups$ that is not
         yet mentioned in neither $ns$ nor $cenv$.
      4. Extend $ns$ by adding all type classes mentioned in any of
         the instances in $is$ but that is not yet mentioned in
         neither $ns$ nor $cenv$.
    - Return $cenv$

    In our example with \inlhask{[Applicative]} as the starting list,
    we would start by finding all information about
    \inlhask{Applicative} and adding \inlhask{Functor} and
    \inlhask{Monoid} to $ns$.[fn:4] The next step would be looking up
    the information of, for instance, \inlhask{Monoid}. Since there
    are no superclasses for this class then only classes mentioned in
    the instances are added. In this case, one of the instances
    mentions a class which is already in $cenv$, \inlhask{Monoid}, and
    this particular class is therefore not added to $ns$ since there
    is no need to recalculate the mapping for this name.[fn:5]

    The algorithm above is the most straightforward way known to the
    author to find all information about the type classes possibly
    used when generating values. However, the proposed algorithm has
    some problems when applied to, for instance, the list
    \inlhask{[Num]}. The resulting class environment is calculated
    very quickly but then compiling this value again in a Haskell
    takes up to a minute on a fairly modern computer. The reason is
    that GHC adds a lot of type classes not normally visible in a
    normal ghci session. The text representation of the final value
    that is spliced into the resulting file is around 700000
    characters long \todo{recheck this value}! Compiling such a large
    expression can take up to one minute or more even on a modern
    computer.

    In future versions of this library, the fourth step should be
    added again. However, some care has to be taken to only include
    classes that are relevant to the current problem. Possible ways to
    solve this is discussed further in section \ref{fut-CE}.

** ExpGen
   \label{expgen}

   The \textsc{ExpGen} module contains the core algorithm and methods
   to generate type-safe expressions. The generation starts in the
   appropriately named function \inlhask{generate} which works by
   finding a random matching \inlhask{Constructor}'s for the current
   goal type and recursively tries to generate expressions of the
   argument types used in the constructor. However, this is not as
   trivial as the above description makes it sound like and the
   following section explains the design choices and the different
   invariants used when implementing the complete algorithm.

*** The ExpGen state
    The \inlhask{ExpGen} type is basically a state monad keeping track
    of and updating relevant information when generating expressions.

    #+BEGIN_HASKELLCODE
    type Nat        = Int
    type NextLambda = Nat
    type NextType   = Nat

    type EGState = (NextLambda, NextType, [Context], StdGen, Substitution)

    newtype ExpGen a = EG (State EGState a)
    instance Monad ExpGen
    instance MonadState EGState ExpGen
    #+END_HASKELLCODE

    The type \inlhask{EGState} is a tuple with several elements. The
    first two elements, \inlhask{NextLambda} and \inlhask{NextType},
    is used to generate unique identifiers for lambda variables and
    type variables respectively. The list of \inlhask{Context}'s
    contains all \inlhask{Constructor}'s introduced in either the
    language definition or in any lambda generated by the algorithm.
    If, for instance, the starting language contains \inlhask{map} and
    \inlhask{id} and the type to generate is
    \inlhask{Int -> Double -> Int}, then the starting context would be
    a singleton list only containing \inlhask{map} and \inlhask{id}.
    The next step would introduce a lambda \inlhask{$\lambda$ x y -> ...},
    effectively adding one more \inlhask{Context} containing
    \inlhask{x} and \inlhask{y} [fn:6] to the list of contexts, and
    continue to generate an expression of type \inlhask{Int} at the
    point of the ellipsis.

    The \inlhask{StdGen} is from the \textsc{System.Random} module and
    is used when selecting random constructors when generating
    expressions. The last value, with type \inlhask{Substitution},
    contains the current guesses for all \inlhask{Undecided} type
    variables. Section \ref{types-subst} contains further elaboration
    on what a \inlhask{Substitution} and how a \inlhask{Undecided}
    type variable is used.

*** Unique types
    Before going into details about the different parts of the
    generation functions it is necessary to discuss the following
    function:

    \begin{haskellcode}
    -- | Given a type replaces all `Forall' bound variables in that type
    -- with unique type variables. The EGState is updated with the next free
    -- type variable id.
    uniqueTypes :: Type -> ExpGen Type
    \end{haskellcode}

    The function \inlhask{uniqueTypes} is applied to types before type
    matching is done. It is also used one time on the starting
    goal-type when first starting to generate expressions. The
    uniqueness of types makes it much easier to implement type
    matching and removes the possibility of introducing loops in the
    substitution during the matching process.

*** Match function
    \label{match}

    The function \inlhask{match} found in the \textsc{ExpGen} module
    implements an algorithm that is close to but not exactly the same
    as standard type matching:

    \begin{haskellcode}
    match :: Monad m => Type -> Type -> StateT Substitution m Type
    match gt t = do
        s <- match' gt t

        let t2  = // apply the substitution s to t

            t2' = // Convert all Forall quantified variables in t2 to
                  // Undecided variables

        return t2'

    match' :: Monad m => Type -> Type -> StateT Substitution m Substitution
    \end{haskellcode}

    \inlhask{match} takes a goal type $gt$ and a matched against type
    $t$ and returns a type inside a state monad. The state that being
    kept is the current guesses for the \inlhask{Undecided} variables
    encountered during type matching. The first function works by
    first calculating a substitution for the second type $t$ by using
    the function \inlhask{match'}. The substitution contained in $s$
    on line 3 corresponds to a substitution returned by normal type
    matching. The rest of the function is to first apply $s$ to $t$
    followed by converting all \inlhask{Forall} quantified variables
    to \inlhask{Undecided} variables.

    \todo{Some examples describing how Undecided works}

*** Selecting a random matching constructor
    \label{random}

    The following function gets a goal type $gt$ and returns a
    randomly selected \inlhask{Constructor} from the current context
    matching the supplied type:

    \begin{haskellcode}
    randomMatching :: Type -> ExpGen (Maybe (Id, Constructor, Substitution))
    \end{haskellcode}

    This function works by looking through each \inlhask{Context},
    filters out those \inlhask{Constructor}'s with no more uses left
    and then runs \inlhask{match} with the goal type $gt$ and the type
    for the current \inlhask{Constructor}. If \inlhask{match} succeeds
    it returns an updated \inlhask{Type} and a \inlhask{Substitution}
    containing new/updated guesses for \inlhask{Undecided} variables
    wrapped in a \inlhask{Just}. The constructor is then saved to a
    list of constructor candidates. If instead a \inlhask{Nothing} is
    returned then the list of candidates is unchanged.

    The last step of the function is simply to randomly select and
    return one of the \inlhask{Constructor}'s by using the
    \inlhask{StdGen} in the \inlhask{EGState}.

*** Generating expressions
    \inlhask{generate} is the only exported function in the
    \textsc{ExpGen} module, i.e. it is the only function that will be
    visible to the end user.

    \begin{haskellcode}
    generate :: Language -> Type -> Seed -> (Maybe Exp, EGState)
    generate lang t seed = runEG seed lang $ do
        t' <- bindForall <$> uniqueTypes t
        generate' t'

    generate' :: Type -> ExpGen (Maybe Exp)
    \end{haskellcode}

    The function \inlhask{generate} is extremely simple since its
    basically a wrapper for the function \inlhask{generate'} where the
    real work is done. Here the different functions presented in the
    last section is combined into a complete algorithm that is used to
    generate expressions. This is also the algorithm presented in
    pseudocode in section \ref{algo:generate}.

    \newpage

* Limitations
  Due to time limitations the scope and complexity of the project was
  reduced by limiting the implementation of the final project. This
  chapter discusses all these limitations and how they affect the
  final product. Further, each subsection contains a short discussion
  about how one might extend the library to eliminate the limitation.

** Expression type
   \label{lim-expressions}

** Type matching
** Rank >1 types
** Class environments
** Type variable arguments
   \label{lim-typearg}

** Equality constraints

\newpage

* Example usage
** Simple usage
** a Do-it-yourself High-Assurance compiler
** Feldspar

\newpage

* Future Work
** Class Environments
   \label{fut-CE}

** More expressions in =defineLanguage=
   \label{fut-defineLanguage}

** Termination strategy
   \label{fut:termination}

** Sub goal ordering
   \label{fut:ordering}

   \newpage

* Related work

\newpage

* Conclusions

\newpage

\section*{References}

# Mark all references as cited
  \nocite{*}

  \printbibliography[heading=none]

* Footnotes

[fn:1] Also note that in this example you cannot use the name "List"
for the list type constructor since a user might add this data type
themselves.

[fn:2] For instance =lookupSubst :: Nat -> Substitution -> Maybe
([Variable], SType)= and \hbox{\tt (|->) :: Nat -> SType -> Substitution}

[fn:3] =Seed= is simply a type alias for an integer.

[fn:4]  \inlhask{Functor} is a superclass of \inlhask{Applicative}
while \inlhask{Monoid} is mentioned in one of the instances.

[fn:5] Further, adding \inlhask{Monoid} to $ns$ again would cause an
infinite loop.

[fn:6] With the appropriate types \inlhask{Int} respectively
\inlhask{Double}.

[fn:7] The other one being \inlhask{generate'}.

[fn:8] Normal matching only needs to look at for all quantified type variables.

[fn:9] Since $t_2$ is a function type.

[fn:10] This is also the term that will be used in the rest of this
thesis.

[fn:11] This is done in \cite{lambda}.

[fn:12] This function is closer to traditional type matching compared
to \textsc{Match}.

[fn:13] A more detailed explanation about $\mathbb{U}$ is found in
section \ref{sec:undecided}.
